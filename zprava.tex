\documentclass[12pt]{article}
%\usepackage{epsf,epic,eepic,eepicemu}
%\documentstyle[epsf,epic,eepic,eepicemu]{article}
%\usepackage[cp1250]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage[czech, english]{babel}
\usepackage{czech}
\usepackage[T1]{fontenc} 
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{lmodern}
\usepackage{float}



\begin{document}
%\oddsidemargin=-5mm \evensidemargin=-5mm \marginparwidth=.08in
%\marginparsep=.01in \marginparpush=5pt \topmargin=-15mm
%\headheight=12pt \headsep=25pt \footheight=12pt \footskip=30pt
%\textheight=25cm \textwidth=17cm \columnsep=2mm \columnseprule=1pt
%\parindent=15pt\parskip=2pt

\begin{center}
\bf Semestrální projekt MI-PAR 2010/2011:\\[5mm]
    Paralelní algoritmus pro řešení problému: Minimálně lomená souvislá čára\\[5mm]
       Tomáš Čejka\\
	   Martin Lukáš\\[2mm]
magisterské studijum, FIT ČVUT, Kolejní 550/2, 160 00 Praha 6\\[2mm]
\today
\end{center}

\section{Definice problému a popis sekvenčního algoritmu}
Práce se zabývá algoritmem pro konstrukci souvislé lomené čáry skládající se z posloupnosti navazujících úseček, která spojí všech k bodů a bude obsahovat minimum zlomových bodů. 
Sekvenční algoritmus je typu BB-DFS s hloubkou prohledávaného prostoru omezenou na k-2. Řešení vždy existuje.

Vstupní a výstupní soubor jsou téměř stejného formátu. Body jsou v souboru reprezentovány dvěmi celými čísly na řádce. U vstupního souboru je navíc na prvním řádku uveden celkový počet čtených bodů, na pořadí bodů nezáleží. U výstupního souboru na pořadí bodů záleží, jejich pořadí udává posloupnost bodů z nichž je konstruován graf lomené čáry.

Pro reprezentaci bodu načteného ze souboru byla vytvořena třída Point. Objekty této třídy jsou uloženy v globálně přístupném dynamicky vytvořeném poli, jehož velikost je rovněž zachycena v globální proměnné.

Při rekurzivním procházení stavového prostoru byl využit implicitní zásobník pro ukládání zpracovávaných stavů. Tento zásobník je tvořen datovou strukturou std::list ze standartní C++ knihovny. Stavy jsou reprezentovány třídou State, jež uchovává pole celočíselných indexů používaných k adresaci v poli načtených bodů. Tato třída také obsahuje operace např. pro expandování stavu na zásobník. 

Expanze je metoda stavu, která vytváří následníky stavu přidáním doposud nepoužitého bodu. Tímto postupem lze rekurzivně generovat kompletní stavový prostor, všechny permutace pořádí bodů. 

Expanduje se vždy stav z vrcholu zásobníku. Při expanzi stavu se počítá cena, nebo-li počet zlomů vytvořených spojením posloupnosti bodů na než ukazují indexy stavu. Tato cena je taktéž součástí stavu, tedy není nutné opakovaně počítat počet zlomů celé čáry, ale pouze vždy při expanzi rozhodnout o inkrementaci ceny.

Pokud stav nelze již expandovat, je porovnána globální minimální cena s nově vypočtenou hodnotou a případně uchováno řešení s aktualizací globálního minima. Během odebírání stavů ze zásobníku je porovnána cena odebraného stavu s globálním minimem, pak je stav dále expandován nebo je smazán.

Pořadí procházení stavů není nijak měněno, tj. stavy nejsou na zásobníku seřazeny dle ceny, i když by to bylo zřejmně vhodné.

Po vyprázdnění implicitního zásobníku je proveden výpis řešení a program je ukončen.


\section{Popis paralelního algoritmu a jeho implementace v MPI}

Po implementaci sekvenčního algoritmu jsme přistoupili k jeho paralelizaci. Paralelizace v našem případě spočívá v sestavení  konečného automatu pro distribuci stavů a mezivýpočtů mezi zásobníky výpočetních uzlů. Je tedy použit totožný sekvenční algoritmus, který je spouštěn paralelně.

Zprávy které jsou mezi uzly zasílány mají nastaven příznak dle něhož je určen stav přijímacího automatu. Jsou to především tyto příznaky:
\begin{itemize}
\item MSG\_DIST\_DATA - příznak šíření počátečních dat, broadcast
\item MSG\_WORK\_REQUEST - příznak žádosti o práci, stavy
\item MSG\_WORK\_TRANSFER - příznak příchozí práce, stavů
\item MSG\_NO\_WORK - příznak odpovědi žádné dostupné práce
\item MSG\_BEST\_GLOBAL\_SOLUTION - příznak zprávy obsahující nejlepší globální řešení
\end{itemize}

Paralelní algoritmus pracuje takto. Výpočetní uzly se nejprve inicializují funkcí MPI\_Init z knihovny MPI. Každému uzlu je přiřazeno unikátní pořadové číslo. Uzel s pořadovým číslem 0 načte data ze souboru a vyšle je hromadným vysíláním(MPI\_Broadcast) ostatním uzlům. Po odeslání těchto uzlů začne svůj lokální sekvenční výpočet, tj. umístí na svůj zásobník první stavy. Ostatní uzly se cyklicky v pořadí sekvenčních čísel uzlů dotazují na práci. Pokud dotazovaný uzel nemá žádný stav na zásobníku, který by mohl zaslat, dotazuje se v pořadí dalšího uzlu. V případě, že uzel může nabídnout stavy, vybere je a zašle je žadateli o práci. 

Výběr stavů ze zásobníku, které budou odeslány pokud je o ně zažádáno, je realizován algoritmem D-ADZ (půlení u dna). Žadatel obdrží stavy ze zásobníku s jednou polovinou stavu co nejblíže dnu. Tento algortimus bylo snadné realizovat, jelikož virtuální zásobník je řešen strukturou spojového seznamu.

Aby nedocházelo ke zbytečnému výpočtu cenově horších stavů než některé z nalezených na jiném uzlu, je implementováno tzv. šíření nejlepších výsledků. Pokud uzel nalezne lepší řešení než znají všechny ostatní uzly, rozešle těmto uzlům celočíselnou hodnotu pomocí neblokujícího MPI\_ISend ve zprávě s příznakem MSG\_BEST\_GLOBAL\_SOLUTION. Uzly si tuto globálně nejlepší cenu uloží a cenově horší stavy již neexpandují. Paralelní algoritmus je typu G-PBB-DFS-D.

Pokud uzel jež žádá o práci ji nedostane od žádného z uzlů, pak postupuje dle \href{https://edux.fit.cvut.cz/courses/MI-PAR/labs/prohledavani_do_hloubky#algoritmus_pro_distribuovane_ukonceni_paralelniho_vypoctu_aduv}{algoritmu pro distribuované ukončení paralelního výpočtu (ADUV)}. Reakce na příchod WHITE/BLACK tokenu je součástí stavového automatu pro komunikaci. Pokud je výpočet ukončen, tj. všechny uzly obdrží zprávu s příznakem MSG\_FINISHING, je nutné přenést nejlepší známé řešení na uzel 0. Toto je řešeno použitím funkce MPI\_Barrier, jež slouží pro synchronizaci všech uzlů. Po této synchronizaci je rozesláno hromadným vysíláním cena nejlepšího řešení. Uzel jež toto řešení vypočítal jej zašle uzlu 0, který ho zapíše do souboru a výpíše na obrazovku. 



\begin{comment} 
rozdělování zásobníku, 
přidělování práce, 
šíření nejlepších výsledků,
ukončovací algoritmus (ADUV)
\end{comment}

\section{Naměřené výsledky a vyhodnocení}
\subsection{Způsob měření}
Měření probíhalo za použitím knihovních funkcí OpenMPI. Konkrétně se jednalo o funkce MPI\_Barrier(), 
která nám zaručila synchronizaci všech procesorů, a funkci MPI\_Wtime(), která vrací čas v sekundách.
Čas výpočtu jsme změřili jako rozdíl časů \(t_2\) a \(t_1\), kde \(t_1\) je čas před započetím výpočtu
tesně za inicializací knihovny OpenMPI a \(t_2\) je čas na konci výpočtu před ukončením práce s knihovou.

\paragraph{Část kódu po inicializaci:}
\begin{verbatim}
 MPI_Barrier(MPI_COMM_WORLD);
 t1 = MPI_Wtime();
\end{verbatim}
\paragraph{Část kódu před ukončením:}
\begin{verbatim}
 MPI_Barrier(MPI_COMM_WORLD);
 t2 = MPI_Wtime();
 if (cpu_id == CPU_MASTER) {
      std::cout << "Spotrebovany cas: " << t2 - t1 << std::endl;
 }
\end{verbatim}

Měřili jsme na třech různých instancích problému se 16-ti body v rovině. Tyto tři instance jsme
pojmenovali \emph{Test A}, \emph{Test B} a \emph{Test C}. Naměřili jsme dobu sekvenčního výpočtu
a následně paralelního výpočtu se stejným algoritmem výpočtu. Pro všechny paralelní testy jsme měřili úlohu na
různém počtu procesorů, konkrétně pro 2, 4, 8, 16, 24 a 32 procesorů. Všechna měření jsme zopakovali
při spuštění na propojovací síti InfiniBand a Ethernet.

Naměřené hodnoty jsme zanesli do tabulek rozdělených podle typu propojovací sítě. Nakonec jsme spočítali
zrychlení oproti sekvenčnímu řešení a výsledky opět zanesli do tabulek.

Pomocí OpenOffice.org jsme nechali vykreslit grafy znázorňující závislost času výpočtu na počtu procesorů
a závislost zrychlení na počtu procesorů. Všechny grafy jsou v příloze.
\subsection{Naměřené časy}
\begin{table}[H]
\begin{center}
\begin{tabular}{|r|r|r|r|}
\hline
Počet CPU & A & B & C\\
\hline
1 & 321,8 & 307,3 & 338,6\\
\hline
2 & 39,46390 & 36,33120 & 40,27212\\
\hline
4 & 13,18690 & 12,84250 & 21,87080\\
\hline
8 & 7,81430 & 10,90410 & 15,13350\\
\hline
16 & 7,51740 & 8,99971 & 11,43290\\
\hline
24 & 37,14640 & 7,44230 & 9,58400\\
\hline
32 & 6,92410 & 7,53790 & 9,39125\\
\hline
\end{tabular}
\end{center}
\caption{Propojovací síť Ethernet}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}{|r|r|r|r|}
\hline
Počet CPU & A & B & C\\
\hline
1 & 321,8 & 307,3 & 338,6\\
\hline
2 & 38,95370 & 35,46150 & 40,27100\\
\hline
4 & 12,20080 & 12,45520 & 21,30230\\
\hline
8 & 7,14178 & 10,43290 & 15,05280\\
\hline
16 & 6,55517 & 8,99971 & 11,43290\\
\hline
24 & 6,21340 & 7,14230 & 8,85400\\
\hline
32 & 6,24150 & 7,13790 & 8,42100\\
\hline
\end{tabular} 
\end{center}
\caption{Propojovací síť InfiniBand}
\end{table}

\subsection{Spočítané zrychlení}
\begin{table}[H]
\begin{center}
\begin{tabular}{|r|r|r|r|}
\hline
Počet CPU & A & B & C\\
\hline
1 & 1 & 1 & 1\\
\hline
2 & 8,15 & 8,78 & 8,99\\
\hline
4 & 24,40 & 24,84 & 16,55\\
\hline
8 & 41,18 & 29,26 & 23,92\\
\hline
16 & 42,81 & 35,45 & 31,66\\
\hline
24 & 45,03 & 42,86 & 37,77\\
\hline
32 & 46,48 & 42,32 & 38,55\\
\hline
\end{tabular}
\end{center}
\caption{Zrychlení Propojovací síť Ethernet}
\end{table}

\begin{table}[H]
\begin{center}
\begin{tabular}{|r|r|r|r|}
\hline
Počet CPU & A & B & C\\
\hline
1 & 1 & 1 & 1\\
\hline
2 & 8,26 & 9,00 & 8,99\\
\hline
4 & 26,38 & 25,61 & 16,99\\
\hline
8 & 45,06 & 30,58 & 24,05\\
\hline
16 & 49,09 & 35,45 & 31,66\\
\hline
24 & 51,79 & 44,66 & 40,89\\
\hline
32 & 51,56 & 44,69 & 42,99\\
\hline
\end{tabular} 
\end{center}
\caption{Zrychlení Propojovací síť InfiniBand}
\end{table}
Zrychlení nám vyšlo superlineární pro všechna měření paralelní úlohy, 
protože platí $$S > p$$, kde \(S\) je zrychlení a \(p\) je počet procesorů. Důvodem takového zrychlení je vhodné rozesílání
nejlepších dosažených výsledků a tím i četné ořezávání stavového prostoru.

\subsection{Vyhodnocení}
Každý procesor má vlastní čítač, který inkrementuje pokaždé, když žádá nějaký jiný procesor o práci. Tím je zajištěné,
že procesory budou žádostmi zatěžovány rovnoměrně. Při rozdělování zásobníku a následném odeslání práce se dbá na to,
aby odesílané stavy nebyly příliš rozpracované, protože z hlediska zpoždění při komunikaci je rychlejší, když procesor
stav dopočítá sám, než aby tento stav poslal pro expandování jinému procesoru. Kdyby se totiž posílaly stavy blízké
listům stavového prostoru, procesory, které práci dostávají, by žádali o práci mnohem častěji.

\begin{comment}
Během implementace a testování jsme empiricky zjistili, že je výhodné, když se zásobník nedělí přesně na polovinu,
ale odesílá se část, která je o něco menší než polovina. Tím jsme docílili toho, že nultému procesoru by měla dojít práce
jako poslednímu, což je důležité z hlediska ukončovacího algoritmu, který je startován vždy od nultého procesoru.
Stav, kdy nultému procesoru dojde práce dříve než ostatním je nežádoucí, protože nultý procesor začne posílat pešky a čekat
na ukončení práce ostatních procesorů. Už nežádá další práci.
\end{comment}

Protože jsme neměli z časových důvodů (čekání ve frontě na clusteru) a kvůli omezeným prostředkům možnost změřit dobu 
zpracování úlohy pro 16 bodů na více než 32 procesorech, nejsme schopni přesně určit, pro kolik procesorů převáží komunikace
natolik, že již nebude výhodné počet procesorů zvyšovat. Z grafu zrychlení však můžeme pozorovat snižující se tendenci růstu
a z toho usuzujeme, že pro 16 bodů mez, za kterou již není účinné problém rozkládat, leží kolem 40 procesorů.

\section{Závěr}
Měřením jsme ověřili existenci zrychlení při použití paralelizace sekvenčního řešení problému, které
závisí na počtu použitých procesorů.
Při implementaci jsme se seznámili se základními funkcemi a vlastnostmi knihovny pro synchronizaci paralelních algoritmů
pracující na bázi tzv Message Passing. Konkrétně se jednalo se o velmi rozšířenou knihovnu OpenMPI.

Vzhledem ke vzrůstajícímu významu paralelizace a distribuovaných výpočtů v oblasti informačních technologií
pro nás bylo seznámení se s paralelním programováním velmi důležité a práce s OpenMPI přínosná.
\section{Literatura}
\begin{enumerate}
\item \href{https://edux.fit.cvut.cz/courses/MI-PAR/labs/prohledavani_do_hloubky}{Stránky cvičení - prohledávání do hloubky}
\item \href{https://edux.fit.cvut.cz/courses/MI-PAR/labs/poznamky_k_implementaci}{Stránky cvičení - poznámky k implementaci}
\end{enumerate}


\appendix
\section{Grafy závislosti času na počtu procesorů}
\subsection{Propojovací síť InfiniBand}
Grafy závislosti času na počtu procesorů při použití propojovací sítě InfiniBand.
\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testAinfib.png}
\caption{Test A}
\label{fig:testAinfib}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testBinfib.png}
\caption{Test B}
\label{fig:testBinfib}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testCinfib.png}
\caption{Test C}
\label{fig:testCinfib}
\end{center}
\end{figure}

\subsection{Propojovací síť Ethernet}
Grafy závislosti času na počtu procesorů při použití propojovací sítě Ethernet.
\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testAeth.png}
\caption{Test A}
\label{fig:testAether}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testBeth.png}
\caption{Test B}
\label{fig:testBether}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/testCeth.png}
\caption{Test C}
\label{fig:testCether}
\end{center}
\end{figure}

\section{Grafy zrychlení}
Grafy zobrazující závislost zrychlení výpočtu na počtu procesorů.
\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/zrychleniinf.png}
\label{fig:zrychleniinf}
\caption{InfiniBand}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=8cm]{grafy-zprava/zrychlenieth.png}
\label{fig:zrychlenieth}
\caption{Ethernet}
\end{center}
\end{figure}

\end{document}
